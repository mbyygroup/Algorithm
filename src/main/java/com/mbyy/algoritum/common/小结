# java数据结构的类库
java.util.*

# 数据结构概念
1.数据结构是指数据在计算机内存空间中或者磁盘中的组织形式
2.正确选择数据结构会使程序的效率大大提高
3.数据结构的例子有数组,栈和链表
4.算法是完成特定任务的过程
5.在java中算法经常通过类的方法实现
6.数据结构和算法可以被用来建造数据库
7.一些数据结构的用途是作为程序员的工具:他们帮助执行算法
8.其他数据结构可以模拟现实世界中的情况,比如城市之间的电话线网
9.数据库是指由许多类似的记录组成的数据存储的集合
10.一条记录经常表示现实世界中的一个事物,例如一名雇员或一个汽车零件
11.一条记录被分成字段,每个字段都存储了有这个纪录所描述事物的一条特征
12.一个关键字是一条记录中的一个字段,通过它可以对数据执行许多操作.例如,认识记录可以通过LastName字段进行排序
13.可以搜索数据库以便找到关键字字段有定值的所有记录,这个值被称为查找关键字

# 数组
1.java中的数组是对象,由new操作符创建
2.无序数组可以提供快速的插入,但查找和删除较慢
3.将数组封装到类中可以保护数组不被随意更改
4.类的接口由类用户可访问的方法(有时还有字段)组成
5.类的接口被设计成使类用户的操作更加简单
6.有序数组可以使用二分查找
7.以B为底A的对数(大概)实在结果小于1之前用B除以A的次数
8.线性查找需要的时间与数组中数据项的个数成正比
9.二分查找需要的时间与数组中数据项的个数的对数成正比
10.大O表示法为比较算法的速度提供了一种方便的方法
11.O(1)级时间的算法是最好的,O(logN)次之,O(N)为一般,O(N2)最差

# 简单排序
1.排序包括比较数组中数据项的关键字和移动相应的数据项(实际上,是数据项的引用),知道他们排好序为止
2.不变性是指在算法运行时保持不变的条件
3.冒泡排序算法是效率最差的算法,也是最简单的
4.插入排序是所有O(N2)级别排序算法中应用最多的
5.如果具有相同关键字的数据项,经过排序他们的顺序保持不变,这样的排序就是稳定排序
6.简单排序算法除了需要厨师数组之外,都只需要一个临时变量

# 栈
1.栈,队列和优先级队列是经常用于简化某些程序操作的数据结构
2.这三个数据结构中,只有一个数据项可以被访问
3.栈允许访问最后一个插入的数据项
4.栈中重要的操作是在栈顶插入(压入)一个数据项,以及从栈顶移除(弹出)一个数据项
5.队列只允许访问第一个插入的数据项
6.队列的重要操作是在队尾插入数据项和在队头移除数据项
7.队列可以实现为循环队列,它基于数组,数组下标可以从数据末端回绕到数组的开始位置
8.优先级队列允许访问最小(或者有时是最大)的数据项
9.栈,队列和优先级队列可以用数组实现,也可以用链表或其他机制实现
10.普通算术表达式是由中缀表达时表示的,这种命名的原因是操作符写在两个操作数的中间.
11.在后缀表达式中,操作符跟在两个操作数的后面
12.算术表达式求值通常都是先转化为后缀表达式,然后再求后缀表达式的值
13.在中缀表达式转换到后缀表达式以及求后缀表达式的值的过程中,栈都是很有用的工具

# 链表
1.链表包含一个linkedList对象和许多Link对象
2.linkedList对象包含一个引用,这个引用通常叫做first,它指向链表的第一个链接点
3.每个Link对象包含数据和一个引用,通常叫做next,它指向链表的下一个链结点
4.next字段为null值意味着链表的结尾
5.在表头插入链接点需要把新链接点的next字段指向原来的第一个链接点,然后把first指向新链接点
6.在表头删除链接点要把first指向first.next
7.为了遍历链表,从first开始,然后从一个链接点到下一个链接点,方法是用每个链接点的next字段找到下一个链接点
8.通过遍历链表可以找到拥有特定值得链结点.一旦找到,可以显示,删除或用其他方法操纵链结点
9.新链结点可以插入在某个特定值得链结点的前面或后面,首先要遍历找到这个链结点
10.双端链表在链表中维护一个指向最后一个链结点的引用,他通常和first一样,叫做last
11.双端链表允许在表尾插入数据项
12.抽象数据类型是一种数据存储类,不涉及他的实现
13.栈和队列是ADT.它们既可以用数组实现,又可以用链表实现
14.有序链表中,链结点按照关键值生序(有时是降序)排列
15.在有序链表中插入需要O(N)的时间,因为必须找到正确的插入点.最小值链结点的删除需要O(1)的时间
16.双向链表中,每个链结点包含对前一个链结点的引用,同时有对后一个链结点的引用
17.双向链表允许反向遍历,并可以从表尾删除
18.迭代器是一个引用,它被封装在类对象中,这个引用指向相关联的链表中的链结点
19.迭代器方法允许使用者沿链表移动迭代器,并访问当前指示的链结点
20.能用迭代器遍历链表,在选定的链结点(或所有链结点)上执行某些操作

# 递归
1.一个递归的方法每次用不同的参数值反复调用自身
2.某种参数值使递归的防范返回,而不再调用自身,这称为基值情况
3.当递归方法返回时,递归过程通过逐渐完成各层方法实力的未执行部分,而从最内层返回到最外层的原始调用处
4.三角数字是它本身以及所有比他小的数字的和,例如4的三角数字是10,因为4+3+2+1=10
5.一个数的阶乘是它自身和所有比它小的数的乘积,例如4的阶乘是4*3*2*1=24
6.三角数字和阶乘都可以通过递归的方法来实现
7.一个单词的全排列(它的n个字母的所有可能排列)可以通过反复的轮换它的字母以及全排列他最右边的n-1个字母来递归得到
8.二分查找可以通过检查查找关键字在有序序列的哪一半,然后在这一半做相同的事情,这写都可以用递归来实现
9.汉诺塔的问题包含三个塔座和任意数量的盘子
10.汉诺塔问题可以用递归来解决:拔出了最低端盘子外的所有盘子形成的子树移动到一个中介塔座上,然后把最低端的盘子移动
到目标塔座上,最终把那个子树移动到目标塔座上
11.归并两个有序数组意思是创建第三个数组,这个数组按顺序存储从这两个有序数组中取到的所有数据项
12.在归并排序中,一个大数组的单个数据项的子数组归并为两个数据项的子数组,然后两个数据项的子数组归并为4个数据项的
子数组,如此下去直到所有的数组数据项有序
13.归并排序需要O(N*logN)时间
14.归并排序需要一个大小等于原来数组的工作空间
15.对于三角数字,阶乘,单词字母全排列以及二分查找,他们的递归的方法只包含一次对自身的调用(在二分查找的代码中显示有
两次,但是在任何给定代码的运行中只有一次自身的调用执行了)
16.对于汉诺塔和归并排序问题,它们的递归的方法包括两次递归调用
17.任何可以用递归完成的操作都可以用一个栈来实现
18.递归的方法可能效率低.如果是这样的话,有时可以用一个简单循环或者是一个基于栈的方法来替代它

# 高级排序
1.希尔排序将增量应用到插入排序,然后逐渐缩小增量
2.n-1增量排序表示每隔n个元素进行排序
3.被称为间隔序列或者间距序列的数列决定了希尔排序的排序间隔
4.常用的间隔序列是由递归表达式h=h*3+1生成的,h的初始值为1
5.一个容纳了1000个数据项的数组,对它进行希尔排序可以是间隔序列为364,121,40,13,4,最后是1的增量排序
6.希尔排序很难分析,但是它运行的时间复杂度大约为O(N*logN).这比时间复杂度为O(N2)的排序算法要快,比如插入排序
7.划分数组就是把数组分为两个子数组,在一组中所有的数据项关键字的值都小于指定的值,而在领一族中所有数据项关键字的值
则大于或等于给定值
8.枢纽是在划分的过程中确定数据项应该放在哪一组的值.小于枢纽的数据项都放在左边一组,而大于枢纽的数据项都放在右边一
组
9.在划分算法中,在各自的while循环中的两个数组下标的指针,分别从数组的两端开始,相向移动,查找需要交换的数据项
10.当一个数组下标指针找到一个需要交换的数据项时,它的while循环终止
11.当两个while的循环都终止时,交换着两个数据项
12.当两个while循环都终止时,并且两个子数组的下标指针相遇或者交错,则划分过程结束
13.划分操作有限性的时间复杂度为O(N),做N+1或N+2次的比较以及少于N/2次的交换
14.划分算法的内部while循环需要额外的检测,以防止数组下标越界
15.快速排序划分一个数组,然后递归调用自身,对划分的得到的两个子数组进行快速排序
16.只含有一个数据项的子数组定为已经有序,这一点可以作为快速排序算法的基值(终止)条件
17.快速排序算法划分时的枢纽是一个特定数据项关键字的值,这个数据项称为pivot(枢纽)
18.在快速排序的简单版本中,总是由子数组的最右端的数据项作为枢纽
19.划分的过程中枢纽总是放在被划分子数组的右界,它不包含在划分过程中
20.划分之后枢纽也换位,被放在两个划分子数组之间,这就是枢纽的最终排序位置
21.快速排序的简单版本中,对已经有序(或者逆序)的数据项排序的执行效率只有O(N2)
22.更高级的快速排序版本中,枢纽是子数组中第一个,最后一个以及中间一个数据项的中值.这称为"三数据项取中"划分
23.三数据项取中划分有效的解决了对已有序数据项排序是执行效率仅为O(N2)的问题
24.在三数据项取中划分中,在对左端,中间以及右端的数据项取中值的同时对他们进行排序.
25.这个排序算法消除了划分算法内部while循环中对数据越界的检测
26.快速排序算法的时间复杂度为O(N*log2N)(除了用简单的快速排序版本对已有序的数据项排序的情况)
27.子数组小于一定容量(切割界限,cutoff)时用另一种方法来排序,而不用快速排序
28.通常用插入排序对小于切割界限的子数组排序
29.在快速排序已经对大于切割界限的子数组排序完之后,插入排序也可用于整个的数组
30.基数排序的时间复杂度和快速排序相同,只是它需要两倍的存储空间

# 二叉树
1.树由边(直线)连接的节点(圆)组成
2.跟是树中最顶端的节点:它没有父节点
3.二叉树中,节点最多有两个子节点
4.二叉搜索树中,所有A节点左边子孙节点的关键字值都比A小,所有右边子孙节点的关键字值都大于(或等于)A.
5.树执行查找,插入,删除的时间复杂度都是O(logN).
6.节点表示保存在树中的数据对象
7.程序中通常用节点到子节点的引用来表示边(有时也用到节点的父节点的引用)
8.遍历树是按某种顺序访问树中的所有的节点
9.最简单的遍历方法是前序,中序和后续.
10.非平衡树是指根左边的后代比右边多,或者相反,右边的子代比左边多
11.查找节点需要比较要找的关键字的节点和关键字值,如果要找节点的关键字值小就转向那个节点的左子节点,如果大
就转向右子节点
12.插入需要找到要插入新节点的位置并改变它的父节点的子字段来指向它
13.中序遍历按照关键值的生序访问节点
14.前序和后序遍历对解析代数表达式是有用的
15.如果一个节点没有子节点,删除它只要把它的父节点的子字段设置为null即可
16.如果一个节点有一个子节点,把它父节点的子字段置为它的子节点就可以删除它
17.如果一个节点有两个子节点,删除它要用的后继来代替它
18.A节点的后继是以A的右子节点为根的子树中关键值最小的那个节点
19.删除操作中,如果节点有两个子节点,会根据后继是被删节点的右子节点还是被删节点右子节点的左子孙节点出现两
种不同的情况
20.数组中重复关键字值的节点会产生一些问题,因为只有第一个能被查找到
21.在计算机存储时可以用数组表示数,不过基于引用的方法更常用
22.哈弗曼树是一种二叉树(不是二叉搜索树),用于数据压缩算法,这种方法称为哈弗曼编码
23.哈弗曼编码中,最经常出现的字符的编码位数最少,很少出现的字符编码为数要多一些

# 红黑树
1.保持二叉搜索树的平衡是非常重要的,这样可以使找到给定节点所必须的时间尽可能短.
2.插入有序的数据将创建最不平衡的树,它查找的时间复杂度为O(N)
3.在红黑平衡的方法中,每个节点都有一个新的特征:它的颜色不是红的就是黑的
4.一组称为红黑规则的规则,详细说明了允许排列不同颜色节点的方法
5.当插入(或删除)一个节点时应用这些规则
6.一次颜色变换把一个黑色节点和它的两个红色子节点改成一个红色子节点和两个黑色子节点.
7.在一次旋转中,制定一个节点为顶端节点.
8.右旋把顶端节点移到它的右子节点的位置,并把顶端节点的左子节点移到顶端节点的位置
9.左旋把顶端节点移到它的左子节点的位置,并把顶端节点的右子节点移到顶端节点的位置
10.当顺着树向下查找新节点的插入位置时,应用颜色变换,并且有时应用旋转.颜色变换通过简单的方法,就使树在插入
后恢复成正确的红黑树
11.新节点插入之后,再次检查红红冲突.如果发现有违背红黑规则的现象,执行适当的旋转使树恢复红黑正确性
12.这些调整使树成为平衡的,或者至少大致平衡
13.在二叉树中加入红黑平衡对平均执行效率只有很小的负面影响,然而却避免了对有序数据操作的最坏的性能

# 2-3-4树
1.多叉树比二叉树有更多的关键字和节点
2.2-3-4树是多叉树,每个节点最多有三个关键字和四个子节点
3.多叉树中,节点中数据项按关键字升序排列
4.2-3-4树中,所有的插入都在叶节点上,所有的叶节点在同一层上
5.在2-3-4树中有三种可能的节点:2-节点有一个关键字和两个子节点,3-节点有两个关键字和是哪个子节点,4-节点有
三个关键字和四个子节点
6.2-3-4树中没有1-节点
7.在2-3-4树中查找时,检查每个节点的关键字,没有找到时,如果要查找节点的关键字比key0小,下一个节点就是child0
如果要查找节点的关键字在key0和key1之间,下一个节点就是child1;如果要查找节点的关键字在key1和key2之间,
下一个节点就是child2;如果要查找节点的关键字大于key2,下一个节点就是child3
8.在2-3-4树中插入需要在查找插入点的过程中,顺着树的路径向下分裂路径上每个满的节点
9.分裂根要创建两个新节点:分裂出另一个节点,创建一个新节点
10.只有分裂根时2-3-4树的高度才会增长
11.2-3-4树和红黑树之间存在一对一的对应关系
12.要把2-3-4树转化为红黑树,需要把两个2-节点变成黑色节点,把每个3-节点变成一个黑色的父节点和一个红色的子
节点,把每个4-节点变成一个黑色父节点和两个红色子节点
13.当3-节点转化成一个父节点和一个子节点时,每个节点都可以做父节点
14.2-3-4树中分裂节点和在红黑树中进行颜色变换是一样的
15.红黑树中的旋转对应于转化3-节点时两种可能的(倾斜)方向间变化
16.2-3-4树的高度log2N
17.2-3-4树很浪费空间,因为很多节点还不满一半
18.2-3树类似于2-3-4树,除了它只能有一个或两个数据项以及1,2或3个子节点
19.在2-3树中插入需要找到合适的叶节点,然后从叶节点开始向上分裂,直到找到不满的节点
20.外部存储的意思是在主存外面保存数据,通常是在磁盘上
21.外部存储器比主存大,便宜(每字节),但是慢
22.外部存储器中的数据通常需要在主存间来回传送,一次传送一块
23.在外部存储器里的数据可以按关键字顺序有序排列.这样查找很快,但插入(或删除)很慢
24.B-树为多叉树,每个节点可以有几十或上百个关键字和子节点
25.B-树中子节点的个数总是比关键字的个数多1
26.为达到更好的性能,B-树通常在一个节点中保存一块的数据
27.如果查找条件涉及多个关键字,在文件所有的记录中顺序查找可能是最实用的方法

# 哈希表
1.哈希表基于数组
2.关键字值的范围通常比数组容量大
3.关键字值通过哈希函数映射为数组的下标
4.英文字典是一个数据库的典型例子,它可以有效的用哈希表来处理
5.一个关键字哈希化到已占用的数组单元,这种情况叫做冲突
6.冲突可以用两个方法解决:开放地址法和链地址法
7.在开放地址法中,把冲突的数据项放在数组的其他位置
8.在链地址法中,每个数组单元包含一个链表,把所有映射到同一个数组下标的数据项都插入到这个链表中
9.开发地址法共有线性探测,二次探测和再哈希三种
10.在线性探测中,步长总为1,所以如果x是哈希函数计算得到的数组下标,那么探测序列就是x,x+1,x+2,x+3,以此类推
11.找到一个特定项需要经过的步数叫做探测长度
12.在线性探测中,已填充单元的长度不断增加.他们叫做首次聚集,这会降低哈希表的性能
13.在二次探测中法,x的位移是步数的平方,所以探测序列就是x,x+1,x+4,x+9,x+16,以此类推
14.二次探测消除了首次聚集,但是产生了二次聚集,它比首次聚集的危害略小
15.二次聚集的发生是因为所有映射到同一个单元的呢关键字,在探测过程中执行了相同的序列
16.发生上述情况是因为步长只依赖于哈希值而与关键字无关
17.在再哈希法中,步长依赖于关键字,且从第二个哈希函数中得到
18.在再哈希法中,如果第二个哈希函数返回一个值s,南无探测序列就是x,x+s,x+2s,x+3s,x+4s,以此类推.这里s由关
键字得到,但探测过程中保持常量
19.装填银子是表中数据项数和数组容量的比值
20.开放地址法中的最大装填因子应该在0.5附近,,若具有相同的装填因子,对于再哈希法来说,查找的平均探测长度为2
21.在开放地址法中,当装填因子接近1时,查找时间趋于无限
22.在开放地址法中,关键是哈希表不能填的太满
23.对于链地址法,装填因子为1比较合适,这时成功的探测长度平均为1.5,不成功的是2.0
24.链地址法的探测长度随着装填因子变大而线性增长
25.字符串可以这样哈希化,每个字符乘以常量的不同次幂,求和,然后用取模操作符(%)缩减结果,以适应哈希表的容量
26.如果在horner方法中用多项式表达哈希化,每一步中都应用取模操作符,以免发生溢出
27.哈希表的容量通常是一个质数,这在二次探测和再哈希法中非常重要
28.哈希表可用于外部存储,一种做法是用哈希表的单元存储磁盘文件的块号码

# 堆
1.在一个升序优先级队列中,最大关键字的数据项被称为有最高的优先级.
2.优先级队列是提供了数据插入和移除最大(或最小)数据项方法的抽象数据模型(ADT)
3.堆是优先级队列ADT的有效的实现形式
4.堆提供移除最大数据项和插入的方法,时间复杂度为O(logN)
5.最大数据项总是在根的位置上
6.堆不能有序的遍历所有的数据,不能找到特定关键字数据项的位置,也不能移除特定关键字的数据项
7.堆通常用数组来实现,表现为一棵完全二叉树.根节点的下标为0,最后一个节点的下标为N-1
8.每个节点的关键字都小于它的父节点,大于它的子节点
9.要插入的数据项总是先被存放到数组的第一个空的单元中,然后再向上筛选它至适当的位置
10.当从根一出一个数据项时,用数组中最后一个数据项取代它的位置,然后再向下筛选这个节点至适当的位置
11.向上筛选和向下筛选算法可以被看作是一系列的交换,但更有效的做法是进行一系列的赋值
12.可以更改任一个数据项的优先级.首先,改变它的关键字.如果关键字增加了,数据项就向上筛选;而如果关键字减少
了,数据项就向下筛选
13,堆的实现可以基于二叉树(不是搜索树),它映射堆得结构:成为树堆
14.存在在树堆中查找最后一个节点或者第一个空的单元的算法
15.堆排序是一种高效的排序过程,它的时间复杂度为O(N*logN)
16.在概念上堆排序的过程包括先在堆中插入N次,然后再作N次移除
17.通过对无序数组中的N/2个数据项使用向下筛选算法,而不做N次插入,可以使堆排序的运行速度更快
18.可以使用同一个数组来存放初始无序的数据,堆以及最后有序的数据.因此,堆排序不需要额外的存储空间

# 图
1.图包含由边连接的顶点
2.图可以表示许多真实世界的情况,包括飞机航线,电子线路和工作调度
3.搜索算法以一种系统的方式访问图中的每个顶点,搜索是其他行为的基础
4.两个主要的搜索算法是深度优先搜索(DFS)和广度优先搜索(BFS)
5.深度优先搜索使用栈实现,广度优先搜索使用队列实现
6.最小生成时(MST)包含连接图中所有顶点所需要的最少数量的边
7.在不带权的图中,简单修改深度优先搜索算法就可以生成它的最小生成树
8.在有向图中,边有方向(一般用箭头表示)
9.拓扑排序算法创建这样一个顶点的排列列表:如果从A到B有一条边,那么在列表中顶点A在顶点B的前面
10.拓扑排序只能在DAG中执行,DAG表示有向无环(没有环存在)图
11.拓扑排序的典型应用是复杂项目的调度,它包含了任务和任务之间的前后关系
12.warshall算法能找到任意顶点与另外顶点之间是否有连接,不管是通过一步还是任意步到达

# 带权图
1.带权图中,边带有一个数字,叫做权,它可能代表举例,耗费,时间或其他意义
2.带权图的最小生成树中所有的顶点和连接他们的必要的边,且这些边的权值最小
3.优先级队列的算法可用于寻找带权图的最小生成树
4.带权图的最小生成树模拟了真实世界的许多情况,例如在两城市间铺设线缆
5.无权图的最短路径问题要找到两点间的路径,且路径长度最短
6.带权图的最短路径问题产生的路径总权值和最小
7.带权图的最短路径问题可以用Diskstra算法解决
8.对于大型的稀疏图,用邻接表表示,相比于用邻接矩阵表示,可以提高算法的运行效率
9.每一对顶点间的最短路径问题是要找到图中每对顶点间的权值和
10.有些图的算法需要指数级时间,因此在顶点多的图中应用不太实际
